---
layout:     post
date:       2022-3-28
author:     "kk"
title: "数据库"
header-style: text
tags:
  - 基础
---



- left join， right join， inner join

  left join 以左表为基准进行匹配，right join以右表为基准进行匹配，inner join 只筛选出满足匹配条件的项，inner join的条数肯定是小于等于left join或right join的

  对于left join，是针对左表中的每一条记录，查找右表，即使不满足匹配条件，也不会剔除，right join类似

  而inner join是会提出不满足匹配条件的记录

- 读写锁(read write lock)

  允许多个进程读，只允许一个进程写。**注意：不光写进程之间是互斥的，而且读进程和写进程也是互斥的，即如果有进程在写，那么就不能读，如果有进程在读，那就不能写！！**

  读锁也叫做，共享锁，S锁

  写锁也叫做，排他锁，X锁

  实现方式：使用两个信号量r、g实现，b表示写进程的数量

  ```
  // 初始化
  Set b to 0.
  r is unlocked.
  g is unlocked.
  
  -------------------------------
  读进程
  // 开始读
  Lock r.
  Increment b.
  If b = 1, lock g.
  Unlock r.
  
  // 结束读
  Lock r.
  Decrement b.
  If b = 0, unlock g.
  Unlock r.
  -------------------------------
  写进程
  // 开始写
  Lock g.
  
  // 结束写
  Unlock g.
  -------------------------------
  ```

  这种写法是读优先，即如果读进程多且块的话，会导致写进程一直无法获取g这个lock，导致写进程饥饿

  当然也有写优先，这样会导致读进程饥饿

  有一些机制去解决进程饥饿的问题

- redo log buffer、 undo buffer、read buffer、write buffer

  - mysql在读数据和写数据的时候，不是直接对硬盘里的表进行操作，因为这样会频繁地进行IO，导致效率很低。所以他会在内存中开辟一个空间作为缓存，有read buffer与write buffer。
  - 在读数据的时候，先去read buffer里读，read buffer里没有才会去磁盘里读。

  - 写的时候，先写入write buffer，等write buffer满了之后，再一次性写到磁盘里。

  - redo log buffer：事务中，每进行一次操作，都会在redo log buffer中记录一次。比如把A = 1 修改为 A = 2 然后修改 A = 3，那么redo log buffer里面记录的就是A = 2, A = 3的操作（**但实际上redo里面还会包含undo的内容，其顺序为：写undo的redo、写undo、修改数据页、写Redo**）。即通过redo，我们可以恢复出事务的每一步。在事务commit后，redo log buffer会写入到磁盘的redo log file里面（采用的是追加的方式），然后才是将内存中修改的数据写回到数据库的表中。

    考虑一种场景：当事务commit后，redo log file已经写入磁盘，在这个时候，突然停电了，导致数据没来得及写回数据库的表中，这个时候可以通过redo log file来进行恢复

  - undo log buffer：undo与redo相反，记录的是A = 1， A = 2的操作，即通过undo，我们可以对事务的每一步进行回退。undo log buffer也会定时写进磁盘里面。

- 

- 隔离级别（isolation level）

  - read uncommited

    

  
