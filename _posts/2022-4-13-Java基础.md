---
layout:     post
date:       2022-4-13
author:     "kk"
title: "Java基础"
header-style: text
tags:
  - 基础
---



## 数据结构

### List

- ArrayList：底层为数组，线程不安全
- Vector：底层也是数组，线程安全
- LinkedList：底层为链表



### Map

- HashMap<K,V>

  jdk 7 之前，使用数组 + 链表

  jdk 8 之后，使用 数组 + 链表 / 红黑树。当且仅当链表的长度大于8 数组大于64 的时候 大于8 的链表会转成树的结构 ，每次添加对象的时候是直接往后追加 

  线程不安全

  多线程下，使用ConcurrentHashMap

  它的遍历顺序是遍历数组+链表的顺序

  key，value允许为空

  当数组容量超过阈值时（数组容量 * 负载因子），会进行扩容

- LinkedHashMap

  底层和HashMap差不多，但是HashMap中数组元素的类型是Node，它是Entry，区别是增加了一对指针，用来指示插入顺序

  所以LinkedHashMap支持按照插入顺序遍历，也支持HashMap的遍历方式

- TreeMap

  底层为红黑树，可以自定义compareTo接口，用来进行插入时的排序

- Hashtable<K,V>

  使用数组 + 链表实现

  key，value都不允许为空

  线程安全

### Set

- HashSet：底层由HashMap实现

  存储值的时候，先计算hashCode，然后调用equals方法，两者都相同才会认为是同一个元素



## 语法

- Java内存模型
  1. **可见性：**　可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。
  2. **原子性：**  原子是世界上的最小单位，具有不可分割性。
  3. **有序性：** 即程序执行的顺序按照代码的先后顺序执行。

- volatile关键字
  1. 线程中读取的时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存
  2. 线程中修改了工作内存中变量的副本，修改之后会立即刷新到主内存

​	 	 volatile可以保证可见性，但是无法保证对变量的任何操作都是原子性的，volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性

​		 synchronized关键字是防止多个线程同时执行一段代码，会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。

- java复制

  - 直接赋值

    只复制引用，实际上两个引用指向同一个对象

  - 浅拷贝

    创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的， 那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象

  - 深拷贝

    深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象

- 反射

  Java能够使用反射的本质是因为，jvm里面有类的元信息，可以根据类的元信息动态创建对象。实际上就是类名与类信息的对应关系，只要有这样的映射关系，就可以实现反射。



## 多线程

- 创建线程的方法：

  - 继承自Thread类，重写run方法

  - 实现Runnable接口，重写run方法

- 线程生命周期

  在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5 种状态

  - new关键字创建了一个线程后，线程处于新建状态
  - 当线程对象调用start()方法后，线程处于就绪状态
  - 线程死亡的四种情况
    - run或call方法执行完成，线程正常结束
    - 线程抛出一个未捕获的 Exception或 Error。
    - 调用stop方法结束线程
    - 调用interrupt方法结束线程
      1. 线程处于阻塞状态：如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时， 会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。 阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让 我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束，实 际上是错的， 一定要先捕获 InterruptedException异常之后通过 break 来跳出循环，才能正
         常结束 run方法。
      2. 线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用 interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。

<img src="C:\Users\97691\AppData\Roaming\Typora\typora-user-images\image-20220415161657881.png" alt="image-20220415161657881" style="zoom: 67%;" />

- sleep与wait的区别
  - sleep是Thread类的方法，wait是Ojbect类的方法
  - sleep不会释放对象锁，wait会释放持有的对象锁
  - 当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此 对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。

- yield

  yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下， 优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。

- join

  join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞 状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。



- 锁

  java中的锁，**锁住的是对象**，在对象头markword里面，有一个锁状态标记以及线程持有的锁用来标记哪个线程持有当前锁

  锁的的一些概念：

  - 可重入锁：也叫做递归锁，指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受
    影响

  - 公平锁：加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得

    非公平锁：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待

  - 独占锁：每次只有一个线程独占资源

    共享锁：允许多个线程共享资源

  - 自旋锁：没获得锁的线程，不是直接就阻塞掉，而是不停地查询锁的状态，直到获得锁。这样做的好处是，线程阻塞到唤起的开销是很大的，而线程查询锁状态代价不高

    自旋锁的缺点：

    - 当一个线程长期占有锁时，那么其他线程要长期自旋，耗费大量的cpu资源，因此一般到达最大自旋时间，会让线程阻塞掉。自旋锁比较适合锁释放比较块的场景
    - 单核cpu下，用自旋锁没多大意义，因为自旋需要不断查询锁状态，会占用cpu，自旋会导致频繁进行线程的切换，效率低。多核cpu下，可以让持有锁的线程继续运行，而查询锁状态可以在其他cpu上进行

  - 悲观锁：认为写多，并发发生的概率高，所以每次读写数据都要上锁

    乐观锁：乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数 据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新）， 如果失败则要重复读-比较-写的操作。 java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。

    

  <img src="C:\Users\97691\AppData\Roaming\Typora\typora-user-images\image-20220416114117078.png" alt="image-20220416114117078" style="zoom:50%;" />

  - synchronized
    1. 作用于普通方法或者是代码块时，锁住的是，调用该方法的对象；作用于静态方法时，锁住的是该类的Class对象
    2. 是一种互斥锁。即一次只允许一个线程进入被锁住的代码块

  - reentrantLock：可重入锁，锁住的是lock这个对象。所以用reentrantLock上锁的时候，一定要是同一个lock对象，如果每个线程里面都创建了一个lock对象，那么就达不到上锁的目的

    ```
    Lock lock = new ReentrantLock();
    lock.lock();
    ...
    lock.unlock();
    ```


- CAS（compare and swap）

  乐观锁底层基于CAS，而CAS基于cpu的一条指令cmpxchg，也是compare and swap的意思

  CAS思想：要进行更新时，比较p指向的值和expect的值，如果是是相等，就认为它没有被别的线程更改过，即可更新为update值。否则，认为它已经被别的线程修改过，不进行更新

  CAS的局限性：

  1. 只能够针对一个共享变量
  2. ABA问题：即一个线程将变量从A修改到B，然后又修改回A，另一个线程是无法区分该变量是否被修改过的

  ```c++
  cmpxchg(void*p, expect, update)   //伪代码
  if(*p == expect)		// 读取的值等于预期的值
  	*p = update	
  	return true;
  else
  	return false;
  	
  ```

  cmpxchg这条指令并不是一个原子操作，因为它涉及到先读内存中的值，读完后进行比较，然后写入新值

  在单核cpu下，因为一条指令是不能在执行过程中被中断打断的，所以虽然涉及到了两次访问内存，但是单核cpu下，是原子性的，不存在数据一致性问题

  而在多核cpu下，有可能出现一个cpu1 正在执行cmpxchg指令，读出来内存中的值，然后cpu2也执行cmpxchg指令，但是它已经完成了该内存区域的修改，此时cpu1读出的值是修改前的值，出现了数据不一致的问题。这是因为cmpxchg在多核cpu下不是原子性的，应该使用lock cmpxchg指令来保证原子性，该指令在cmpxchg指令期间会锁住地址总线，禁止其他cpu访问该内存。这是Pentium 4之前，解决CAS的解决方案，在Pentium 4后，因为锁住总线的代价是很高的，所以进行了一些优化，这涉及到多核cpu cache一致性的问题。

- 多核cache 一致性[^1]

  cpu0， cpu1都有自己的cache，命名为cache0，cache1

  - cpu0读0x40地址的数据，先查自己的缓存，没有，然后查询其他cpu的缓存，也没有，那么它就从内存中读取0x40的数据到cache0中，该cache line标记为exclusive，表示该数据只在一个cpu缓存中存在
  - cpu1读0x40地址的数据，先查自己的缓存，没有，然后查询其他cpu的缓存，发现cache0中有，它就把cache0中对应的数据写到自己的cache1中，并把cache line的标记为shared，表示该数据在多个cpu的缓存中存在，并且缓存中的内容与主存的内容一致
  - cpu0修改0x40地址的数据，发现cache line状态为shared，它会发invalid信号给其他cpu，告诉其他cpu该cache line无效了，cpu1收到invalid信号，会把cache line置为invalid状态，Invalid状态表示表明当前cache line无效。而cpu0会把自己的cache line状态置为modified。Modified表明cache line对应的数据仅在一个CPU私有Cache中被缓存，并且其在缓存中的内容与主存的内容不一致，代表数据被修改。
  - 如果CPU0继续修改0x40数据，此时发现其对应的cache line的状态是Modified。因此CPU0不需要向其他CPU发送消息，直接更新数据即可。
  - 如果0x40所在的cache line需要替换，发现cache line状态是Modified。所以数据应该先写回主存。

​		有了这样的保证之后，cmpxchg就可以不锁定总线就可以实现原子性的目的









[^1]: [多核Cache一致性](https://zhuanlan.zhihu.com/p/115114220)

