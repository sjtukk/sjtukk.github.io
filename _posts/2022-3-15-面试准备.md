---
layout:     post
date:       2022-3-15
author:     "kk"
title: "面试准备"
header-style: text
tags:
  - 面试
---







# 面试问题

## 计算机网络

### TCP协议

- TCP中为什么要三次握手，四次挥手（TCP是全双工的）

  A与B建立连接 

  A向B发出请求，然后B做一次应答，这样就可以确定B是正常的，B向A发一次请求，然后A做一次应答， 这样可以确定A是正常的。本来应该是四次握手的，但是B对A的应答和B对A发的请求合在一次，作为一次，所以只需要三次握手。

  A与B断开连接

  A告知B，要断开连接，B回答A表明我知道了。同样B也要告知A，要断开连接了，A回答B表明我知道了。在断开连接的时候为什么不能将B对A的应答和B对A发的请求合在一次呢？因为这个时候B可能还要向A传递数据，所以B先应答A（表明B知道A要断开连接了，但是B有可能还要传输数据），等数据传输完之后，才会发出断开连接的请求。所以不能合在一起。

  故是：三次握手，四次挥手

- TCP四次挥手中，客户端在发出ACK报文后等待2msl（Maximum Segment Lifetime，最大报文寿命）才关闭客户端，是为了什么？

  - 防止客户端最后一次发给服务器的确认在网络中丢失以至于客户端关闭，而服务端并未关闭，导致资源的浪费。

    如果服务端未收到ACK报文，会重发FIN报文，直到收到ACK后，才会关闭服务端

  - 等待最大的2msl可以让本次连接的所有的网络包在链路上消失，以防造成不必要的干扰

- TCP为什么是安全可靠的？

  - 首先TCP是面向连接的，不像UDP不需要建立连接
  - TCP中含有序号和确认序号，这保证了传输的可靠性
  - 校验和。
  - 超时重传

- TCP建立连接的过程？

  序号：seq（sequence number）序号占32位，用来标记客户端和服务器端之间发送的不同数据包，如客户端发送数据时利用seq对发送的数据包进行标记。
  确认号：ack（acknowledge number）确认号占32位，客户端和服务器端都可以发生，且Ack=seq+1

  ACK：标志位的确认编号，表明确认连接（注意与上面的ack区分）

  SYN：建立一个新连接。
  FIN：断开一个连接。

  下面只体现了标志位，至于seq和ack，跟正常连接的时候没区别，只是第一次建立连接/释放连接的时候，只有seq没有ack，后面都有seq和ack

  - A向B（SYN ）
  - B向A（SYN + ACK ）：
  - A向B（ACK ）：
  - 建立连接成功

- TCP断开连接的过程？
  - A向B（FIN)
  - B向A（ACK）
  - B向A（FIN + ACK)
  - A向B（ACK）
  - 等待2msl
  - 断开连接成功

- TCP的连接状态？[^3]

  - LISTENING 

    提供某种服务，侦听远方TCP端口的连接请求，当提供的服务没有被连接时，处于LISTENING状态，端口是开放的，等待被连接。

  - SYN_SENT (客户端状态)

    客户端发送SYN请求连接，在等待服务器发送ACK的时候，处于SYN_SENT状态

  - SYN_RECEIVED (服务端状态)

    服务端收到客户端的SYN，并发送自己的SYN和ACK时，等待客户端ACK的时候，处于SYN_RECEIVED 状态

  - ESTABLISHED

    ESTABLISHED状态是表示两台机器正在传输数据。

  - FIN-WAIT-1

    主动关闭端应用程序调用close，TCP发出FIN请求主动关闭连接，之后进入FIN_WAIT1状态。

  - FIN-WATI-2

    主动关闭端接到ACK后，就进入了FIN-WAIT-2 .

  - CLOSE-WAIT

    被动关闭端TCP接到FIN后，就发出ACK以回应FIN请求, 并进入CLOSE_WAIT. 

  - TIME-WAIT

    主动关闭端接收到FIN后，TCP就发送ACK包，并进入TIME-WAIT状态,等待足够的时间以确保远程TCP接收到连接中断请求的确认,很大程度上保证了双方都可以正常结束,但是也存在问题，须等待2MSL时间的过去才能进行下一次连接。**状态迁移过程：**

     客户端：

　　　　CLOSED->SYN_SENT->ESTABLISHED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->CLOSED

　　		服务端

　　　　CLOSED->LISTEN->SYN_RECEIVED->ESTABLISHED->CLOSE_WAIT->LAST_ACK->CLOSE

### UDP协议

- 与TCP协议的区别是什么？
  - tcp面向连接，udp无连接
  - tcp传输可靠，udp不可靠
  - UDP支持单播，多播，广播（一对一，一对多，一对全的通信）
     TCP之间仅支持单播（一对一）



### Http协议

- 浏览器输入url后，会进行什么过程？
  - 如果浏览器有缓存，直接显示页面，如果没有缓存，往下执行
  - 将域名解析为ip地址（查询缓存，查询本机host，查询本地DNS，查询DNS根服务器，一级一级网上找，直到查询到IP）
  - 浏览器与服务器发起TCP三次握手
  - 握手成功后，发送http请求
  - 服务器响应请求，通过http返回数据
  - 浏览器根据返回的数据，以及页面的js，生成dom树，进行渲染

​			**http基于TCP协议**

- http协议的特点？

  - 无连接：每次连接只处理一个请求，服务器完成客户端的请求后，TCP就断开连接（http1.0）

    http1.1版本后，允许运行在一个 TCP 连接上发送多个命令和应答。因此大幅度减少了 TCP 连接的建立和断开，提高了效率。

  - 无状态：每一次请求都是独立的，不记录客户端任何行为

    解决方式：cookie和session

- http和https有什么区别？

  - HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。

  - HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。

  - HTTP 的端口号是 80，HTTPS 的端口号是 443。

  - HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的

- http协议由什么组成？

  - 请求报文

    - 请求行：url，http协议版本

    - 请求头部（下面罗列了部分重要的）：

      host：初始url中的主机和端口

      cookie

      Accept-Encoding：浏览器能够进行解码的数据编码方式

      Accept-Charset：浏览器可接受的字符集；

      Connection：表示是否需要持久连接（http1.1以上）

      Content-Length：表示请求消息正文的长度

    - 空行

    - 请求数据

  - 响应报文：

    - 状态行：协议版本，状态码

    - 消息报头

      Content-Encoding：文档的编码(Encode)方法

      Content-Length：表示内容长度

      Set-Cookie：设置和页面关联的Cookie

    - 响应正文

- http协议Get请求和Post请求的区别

  - 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）。而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
  -  Get传输数据是通过URL请求，数据放到url后面，用？和&连接，对用户是可见的，安全性比post低。post请求是将字段和对应的值封装在请求实体中发送给服务器，这个过程对用户不可见
  - 受到url长度的限制，get传输的数据量小，post可以传输大量数据
  - get是会被浏览器主动缓存的，如果下一次传输的数据相同，那么就会返回缓存中的内容，以求更快地展示数据。

- http状态码

  - 1xx     信息，服务器收到请求，需要请求者继续执行操作
    - 100（继续） 服务器已收到请求的第一部分，正在等待其余部分

  - 2xx    成功，操作被成功接收并处理
    - 200（成功） 请求被正确处理并返回了结果
  - 3xx     重定向，需要进一步的操作以完成请求
    - 301：永久性重定向
    - 302：临时重定向
    - 304：发送附带条件的请求时，条件不满足时返回，与重定向无关

  - 4xx     客户端错误，请求包含语法错误或无法完成请求
    - 400：请求报文语法有误
    - 401：请求需要认证
    - 403：请求的对应资源禁止访问
    - 404：服务器找不到对应资源

  - 5xx    服务器错误，服务器在处理请求的过程中发生了错误
    - 500：服务器内部错误
    - 503：服务器正忙




## 操作系统[^4]

- 并行与并发？

  并行：多个事件同一时刻发生

  并发：多个事件同一时间间隔发生，但在某一时刻上只有一个事件在发生

  例子：多核cpu是并行，而在单个cpu上是并发

- 进程与线程的区别？

  - 进程是资源分配的最小单位，而线程是 CPU 调度的最小单位；
  - 创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销；
  - 不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的；
  - 进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉；

- 为什么需要线程？

  - 进程在同一时间只能干一件事情；
  - 进程在执行的过程中如果阻塞，整个进程就会被挂起，即使进程中有些工作不依赖与等待的资源，仍然不会执行。

- 进程状态？

  就绪态、执行态、阻塞态

- 死锁产生的必要条件？

  - 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
  - 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
  - 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
  - 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

- 预防死锁？

  - 破坏请求条件：一次性分配所有资源，这样就不会再有请求了；
  - 破坏请保持条件：只要有一个资源得不到分配，也不给这个进程分配其他的资源：
  - 破坏不可剥夺条件：当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源；
  - 破坏环路等待条件：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反。

- 解除死锁？

  - 资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程（但应该防止被挂起的进程长时间得不到资源）；
  - 撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进程代价的高低进行）；
  - 进程回退：让一个或多个进程回退到足以避免死锁的地步。进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

- 静态链接与动态链接？

  - 静态链接：在编译链接时直接将需要的执行代码拷贝到调用处，优点

    - 优点：就是在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行

    - 缺点：

      空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 

      更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。

  - 动态链接：动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。优点是**多个程序可以共享同一段代码**，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能

    - 优点：

      共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；

      更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。

    - 缺点：

      性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

- 用户态与核心态？
  - `内核态`：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。
  - `用户态`：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。
  - 用户态到和核心态的切换：操作系统执行系统调用，切换到核心态（trap指令）
- 分页与分段的区别？
  - 段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的；（透明的意思是用户看不见）
  - 段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定；
  - 段向用户提供二维地址空间；页向用户提供的是一维地址空间；
  - 段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。

- 物理地址、逻辑地址、虚拟内存
  - 物理地址：它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元真正的地址。
  - 逻辑地址：是指计算机用户看到的地址。
- 页面置换算法

- 典型的锁？

  - 读写锁

    - 多个读者可以同时进行读
    - 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）
    - 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）

  - 互斥锁：一次只能一个线程拥有互斥锁，其他线程只有等待

  - 条件变量

  - 自旋锁

    如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。

- 进程间（IPC，InterProcess Communication）的通信方式？

  - 管道：

    - 它是半双工的，具有固定的读端和写端；

    - 它只能用于父子进程或者兄弟进程之间的进程的通信；

    - 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

  - 消息队列

    - 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符 ID 来标识；
    - 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；
    - 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；
    - 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。

  - 信号量：信号量（semaphore）是一个计数器。用于实现进程间的**互斥与同步**，而不是用于存储进程间通信数据

  - 共享内存：指两个或多个进程共享一个给定的存储区

- 进程调度算法？
  - 先来先服务调度算法
  - 时间片轮转调度算法
  - 短作业优先调度算法
  - 最短剩余时间优先调度算法
  - 优先级调度算法
  - 高响应比优先调度算法



## C++八股文

- 面向对象三大特点：封装、继承、多态
- struct和class的区别？
  - class默认成员都是private，而struct中默认成员都是public
  - class的默认继承也是private，而struct中的默认继承都是public（原来struct也可以继承）。
  - class可以使用模板，而struct不行。

- 内存溢出与内存泄露？

  内存溢出：是指申请内存时申请的空间不够，比如申请的int型的内存空间，但是存进去一个long型的数据。

  - 内存中加载的数据量过于庞大，比如一次性从数据库中读取大量数据。
  - 代码中出现死循环或者循环产生过多重复的实体。
  - 启动参数内存值设定的过小。
  - 使用的第三方软件的bug。

  内存泄露：是指申请内存空间之后，没有释放申请的内存空间。

  - new创建出来的对象没有及时的delete掉，导致了内存的泄露；
  - delete一个void的指针可能会造成内存上的泄露！因为delete一个void的对象指针，它不会调用析构函数，如果该对象里面有指针，最后指针就会没有释放导致内存泄漏。

  

## Java八股文

## 刷题相关

### c++基础

- 引入万能头文件 include<bits/stdc++.h>

- 输入输出

  - scanf：scanf中变量必须用地址

    - %s: 字符串（遇到空格、制表符或者换行符结束），scanf("%s", str)，因为str本来就是地址了，就不能用&str

    - %d：读入十进制整数

    - %f：float 
    - %lf：读入double
    - %c：读入一个字符
    - %%L：读入%

  - printf

    - 保留3位小数输出：printf("%.3f", 变量)

  - cin

    - cin >>: 遇到结束符（Space、Tab、Enter）就结束，且对于结束符，并不保存到变量中

    - cin.get(字符数组名，接收长度，结束符)

      其中结束符意味着遇到该符号结束字符串读取,默认为enter，读取的字符个数最多为（长度 - 1），**因为最后一个为'\0'**。要注意的是，cin.get(字符数组名，接收长度，结束符)操作遇到结束符停止读取，**但并不会将结束符从缓冲区丢弃**，要用cin.getchar把结束符读走

    - cin.getline可以读入空格，以换行符作为结束符

  - cout

- 精确输出的位数

  ```c++
  #include <iostream>
  #include <iomanip>
  int main(){
      double a = 10.234234;
      cout << fixed << setprecision(8) << a << endl;
  }
  ```

- 点运算符（.）用于获取对象成员；

  箭头运算符(—>)用于获取指针指向的对象的成员，其实是个混合运算符，是解引用(*)与点运算符(.)的符合运算

  ```
  Node* p = new Node();
  p —> lchild 等效于 (*p).lchild
  ```

- c++不支持函数内部定义函数，c++11可以定义匿名函数，但还是不显式定义函数

- 红黑树（Red-Black Tree，R-B Tree）[^1][^2]

  红黑树是**特殊的二叉查找树**，意味着它满足二叉查找树的特征：任意一个节点所包含的键值，大于等于左孩子的键值，小于等于右孩子的键值。
  除了具备该特性之外，红黑树还包括许多额外的信息。

  红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。

  **红黑树的特性**:
  **（1）每个节点或者是黑色，或者是红色。**
  **（2）根节点是黑色。**
  **（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]**
  **（4）如果一个节点是红色的，则它的子节点必须是黑色的。**
  **（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。**

  **注意**：
  (01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。
  (02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。

​	  <img src="https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg" alt="img" style="zoom: 67%;" />



​	  红黑树是相对于接近平衡二叉树，又加上它在插入、删除新节点的时候，没有平衡二叉树那样需要大范围调整数的结构，所以它的平均效率较高，广泛应用在需要插入、查找的存储结构中（比如STL中的map、set）

- 常用函数

  - sort(begin, end, cmp)

    ```c++
    bool cmp(T x, T y){
        return x < y;
        // 返回值为假，会互换位置，为真就保持不变
    }
    ```

  - map自定义比较函数

    ```c++
    struct myCmp{
        bool operator()(const int& x, const int& y)const{
            return x < y;
        }
    };
    
    map<int, int, myCmp> mp;
    ```

    

- STL

  大部分函数都是通用的，因为STL就是以模板的思想进行设计的

  | 功能                       | 函数                      |
  | -------------------------- | ------------------------- |
  | 长度                       | size()                    |
  | 迭代器                     | eg: set<int>::iterator it |
  | 查找元素（返回元素的位置） | find(element)             |
  | 清空                       | clear()                   |
  | 计数(返回元素的个数)       | count(element)            |

  - vector

    ```c++
    #include <iostream>
    #include <vector>
    using namespace std;
    
    int main() {
    
        vector<int> vec;
        vec.push_back(100);
        vec.push_back(200);
        vec.push_back(300);
        vector<int> vec1(vec);  // 用vec初始化
        vector<int> vec2(100, 5); // 长度为100，初始值为5
        int length = vec.size();
        bool isEmpty = vec.empty();
        for(vector<int>::iterator it = vec.begin(); it != vec.end(); it++){  // 常用auto it = vec.begin()
            cout << *it << endl;
        }
    	vec.back();
        vec.pop_back();
        vec.clear();	// 清空vec
    }
    ```

  - queue

    ```c++
    #include <iostream>
    #include <queue>
    using namespace std;
    
    int main() {
        queue<int> q;
        q.push(3);
        q.push(4);
        q.push(1);
        cout << q.size() << endl;
        // queue不允许用迭代器遍历
        cout << q.front() << endl;
        cout << q.back() << endl;
        cout << q.empty() << endl;
        q.pop();
    }
    ```

  - stack

    ```c++
    #include <iostream>
    #include <stack>
    using namespace std;
    
    int main() {
        stack<int> s;
        s.push(2);
        s.push(4);
        s.push(6);
        cout << s.size() << endl;
        cout << s.empty() << endl;
        cout << s.top() << endl;
        s.pop();
    }
    ```

  - map

    - 注意：map的迭代器是没有 ++， -- 操作的，因为map底层是红黑树，不是一个连续的结构，无法通过迭代器移动固定长度来进行访问。
    - unordered_map底层是hash表，map底层是红黑树，两者是实现是不一样的。unordered_map的遍历顺序不一定和插入顺序一致，因为遍历是按照哈希表从前往后依次遍历的。

    ```c++
    #include <iostream>
    #include <map>
    using namespace std;
    
    int main() {
        map<int, string> mp;
        mp.insert(pair<int, string>(1, "11111"));   // 插入方式1
        mp[5] = "55555";   // 插入方式2
        mp[2] = "22222";
        cout << mp.size() << endl;
        cout << mp.empty() << endl;
        // 注意：map底层是红黑树，所以遍历顺序不一定是插入顺序
        for(auto it = mp.begin(); it != mp.end(); it++){
            cout << it->first << " " << it->second << endl;   // first指的是key，second指的是value
        }
        if(mp.find(1) != mp.end()) cout << "find!" << endl;
        else cout << "not find !!" << endl;
        mp.clear();
    
    }
    ```

  - set

    ```c++
    #include <iostream>
    #include <set>
    using namespace std;
    
    int main() {
        set<int> st;
        st.insert(1);
        st.insert(10);
        st.insert(5);
        st.insert(-4);
        cout << st.size() << endl;
        st.erase(-4);
        cout << st.size() << endl;
        // 注意：set底层是红黑树，所以遍历顺序不一定是插入顺序
        for(auto it = st.begin(); it != st.end(); it++){
            cout << *it << endl;
        }
    
        if(st.find(1) != st.end()) cout << "find!!" << endl;
        else cout << "not find !!" << endl;
    
        st.clear();
    }
    ```

    







参考资料：

[^1]: [红黑树](https://www.cnblogs.com/skywang12345/p/3245399.html)
[^2]: [视频讲解红黑树](https://www.bilibili.com/video/BV1zU4y1H77f)
[^3]: [TCP连接状态详解](https://www.cnblogs.com/uestc2007/p/15481204.html)

[^4]: [操作系统系列面试题](https://zhuanlan.zhihu.com/p/391883855)

