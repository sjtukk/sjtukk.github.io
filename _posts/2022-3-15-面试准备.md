---
layout:     post
date:       2022-3-15
author:     "kk"
title: "面试准备"
header-style: text
tags:
  - 面试
---



# 面试问题




## 操作系统[^4]

- 并行与并发？

  并行：多个事件同一时刻发生

  并发：多个事件同一时间间隔发生，但在某一时刻上只有一个事件在发生

  例子：多核cpu是并行，而在单个cpu上是并发

- 进程与线程的区别？

  - 进程是资源分配的最小单位，而线程是 CPU 调度的最小单位；
  - 创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销；
  - 不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的；
  - 进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉；

- 为什么需要线程？

  - 进程在同一时间只能干一件事情；
  - 进程在执行的过程中如果阻塞，整个进程就会被挂起，即使进程中有些工作不依赖与等待的资源，仍然不会执行。

- 进程状态？

  就绪态、执行态、阻塞态

- 死锁产生的必要条件？

  - 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
  - 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
  - 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
  - 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

- 预防死锁？

  - 破坏请求条件：一次性分配所有资源，这样就不会再有请求了；
  - 破坏请保持条件：只要有一个资源得不到分配，也不给这个进程分配其他的资源：
  - 破坏不可剥夺条件：当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源；
  - 破坏环路等待条件：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反。

- 解除死锁？

  - 资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程（但应该防止被挂起的进程长时间得不到资源）；
  - 撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进程代价的高低进行）；
  - 进程回退：让一个或多个进程回退到足以避免死锁的地步。进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

- 静态链接与动态链接？

  - 静态链接：在编译链接时直接将需要的执行代码拷贝到调用处，优点

    - 优点：就是在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行

    - 缺点：

      空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 

      更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。

  - 动态链接：动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。优点是**多个程序可以共享同一段代码**，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能

    - 优点：

      共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；

      更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。

    - 缺点：

      性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

- 用户态与核心态？
  - `内核态`：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。
  - `用户态`：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。
  - 用户态到和核心态的切换：操作系统执行系统调用，切换到核心态（trap指令）
- 分页与分段的区别？
  - 段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的；（透明的意思是用户看不见）
  - 段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定；
  - 段向用户提供二维地址空间；页向用户提供的是一维地址空间；
  - 段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。

- 物理地址、逻辑地址、虚拟内存
  - 物理地址：它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元真正的地址。
  - 逻辑地址：是指计算机用户看到的地址。
- 页面置换算法

- 典型的锁？

  - 读写锁

    - 多个读者可以同时进行读
    - 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）
    - 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）

  - 互斥锁：一次只能一个线程拥有互斥锁，其他线程只有等待

  - 条件变量

  - 自旋锁

    如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。

- 进程间（IPC，InterProcess Communication）的通信方式？

  - 管道：

    - 它是半双工的，具有固定的读端和写端；

    - 它只能用于父子进程或者兄弟进程之间的进程的通信；

    - 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

  - 消息队列

    - 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符 ID 来标识；
    - 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；
    - 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；
    - 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。

  - 信号量：信号量（semaphore）是一个计数器。用于实现进程间的**互斥与同步**，而不是用于存储进程间通信数据

  - 共享内存：指两个或多个进程共享一个给定的存储区

- 进程调度算法？
  - 先来先服务调度算法
  - 时间片轮转调度算法
  - 短作业优先调度算法
  - 最短剩余时间优先调度算法
  - 优先级调度算法
  - 高响应比优先调度算法







## 刷题相关

### c++基础

- 引入万能头文件 include<bits/stdc++.h>

- 初始化：

  在函数体之外的变量，会进行默认初始化，但是在函数体内（**包括main函数**）的变量不会进行默认初始化！！！

- 输入输出

  - scanf：scanf中变量必须用地址

    - %s: 字符串（遇到空格、制表符或者换行符结束），scanf("%s", str)，因为str本来就是地址了，就不能用&str

    - %d：读入十进制整数

    - %f：float 
    - %lf：读入double
    - %c：读入一个字符
    - %%L：读入%

  - printf

    - 保留3位小数输出：printf("%.3f", 变量)

  - cin

    - cin >>: 遇到结束符（Space、Tab、Enter）就结束，且对于结束符，并不保存到变量中

    - cin.get(字符数组名，接收长度，结束符)

      其中结束符意味着遇到该符号结束字符串读取,默认为enter，读取的字符个数最多为（长度 - 1），**因为最后一个为'\0'**。要注意的是，cin.get(字符数组名，接收长度，结束符)操作遇到结束符停止读取，**但并不会将结束符从缓冲区丢弃**，要用cin.getchar把结束符读走

    - cin.getline可以读入空格，以换行符作为结束符

  - cout

- 常用函数

  - sort(begin, end, cmp)

    ```c++
    bool cmp(T x, T y){
        return x < y;
        // 返回值为假，会互换位置，为真就保持不变
    }
    ```

  - map自定义比较函数

    ```c++
    struct myCmp{
        bool operator()(const int& x, const int& y)const{
            return x < y;
        }
    };
    
    map<int, int, myCmp> mp;
    ```


  - int 转 string ： to_string

  - string转int：先要将string转成c中的const char*，然后使用atoi

    ```c++
    string str = "123";
    int num = atoi(str.c_str())
    ```

- 精确输出的位数

  ```c++
  #include <iostream>
  #include <iomanip>
  int main(){
      double a = 10.234234;
      cout << fixed << setprecision(8) << a << endl;
  }
  ```

- 点运算符（.）用于获取对象成员；

  箭头运算符(—>)用于获取指针指向的对象的成员，其实是个混合运算符，是解引用(*)与点运算符(.)的符合运算

  ```
  Node* p = new Node();
  p —> lchild 等效于 (*p).lchild
  ```

- c++不支持函数内部定义函数，c++11可以定义匿名函数，但还是不显式定义函数

- 红黑树（Red-Black Tree，R-B Tree）[^1][^2]

  红黑树是**特殊的二叉查找树**，意味着它满足二叉查找树的特征：任意一个节点所包含的键值，大于等于左孩子的键值，小于等于右孩子的键值。
  除了具备该特性之外，红黑树还包括许多额外的信息。

  红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。

  **红黑树的特性**:
  **（1）每个节点或者是黑色，或者是红色。**
  **（2）根节点是黑色。**
  **（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]**
  **（4）如果一个节点是红色的，则它的子节点必须是黑色的。**
  **（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。**

  **注意**：
  (01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。
  (02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。

​	  <img src="https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg" alt="img" style="zoom: 67%;" />



​	  红黑树是相对于接近平衡二叉树，又加上它在插入、删除新节点的时候，没有平衡二叉树那样需要大范围调整数的结构，所以它的平均效率较高，广泛应用在需要插入、查找的存储结构中（比如STL中的map、set）

- STL

  大部分函数都是通用的，因为STL就是以模板的思想进行设计的

  | 功能                       | 函数                      |
  | -------------------------- | ------------------------- |
  | 长度                       | size()                    |
  | 迭代器                     | eg: set<int>::iterator it |
  | 查找元素（返回元素的位置） | find(element)             |
  | 清空                       | clear()                   |
  | 计数(返回元素的个数)       | count(element)            |

  - vector

    ```c++
    #include <iostream>
    #include <vector>
    using namespace std;
    
    int main() {
    
        vector<int> vec;
        vec.push_back(100);
        vec.push_back(200);
        vec.push_back(300);
        vector<int> vec1(vec);  // 用vec初始化
        vector<int> vec2(100, 5); // 长度为100，初始值为5
        int length = vec.size();
        bool isEmpty = vec.empty();
        for(vector<int>::iterator it = vec.begin(); it != vec.end(); it++){  // 常用auto it = vec.begin()
            cout << *it << endl;
        }
    	vec.back();
        vec.pop_back();
        vec.clear();	// 清空vec
    }
    ```

  - queue

    ```c++
    #include <iostream>
    #include <queue>
    using namespace std;
    
    int main() {
        queue<int> q;
        q.push(3);
        q.push(4);
        q.push(1);
        cout << q.size() << endl;
        // queue不允许用迭代器遍历
        cout << q.front() << endl;
        cout << q.back() << endl;
        cout << q.empty() << endl;
        q.pop();
    }
    ```

  - stack

    ```c++
    #include <iostream>
    #include <stack>
    using namespace std;
    
    int main() {
        stack<int> s;
        s.push(2);
        s.push(4);
        s.push(6);
        cout << s.size() << endl;
        cout << s.empty() << endl;
        cout << s.top() << endl;
        s.pop();
    }
    ```

  - map

    - 注意：map的迭代器是没有 ++， -- 操作的，因为map底层是红黑树，不是一个连续的结构，无法通过迭代器移动固定长度来进行访问。
    - unordered_map底层是hash表，map底层是红黑树，两者是实现是不一样的。unordered_map的遍历顺序不一定和插入顺序一致，因为遍历是按照哈希表从前往后依次遍历的。

    ```c++
    #include <iostream>
    #include <map>
    using namespace std;
    
    int main() {
        map<int, string> mp;
        mp.insert(pair<int, string>(1, "11111"));   // 插入方式1
        mp[5] = "55555";   // 插入方式2
        mp[2] = "22222";
        cout << mp.size() << endl;
        cout << mp.empty() << endl;
        // 注意：map底层是红黑树，所以遍历顺序不一定是插入顺序
        for(auto it = mp.begin(); it != mp.end(); it++){
            cout << it->first << " " << it->second << endl;   // first指的是key，second指的是value
        }
        if(mp.find(1) != mp.end()) cout << "find!" << endl;
        else cout << "not find !!" << endl;
        mp.clear();
    
    }
    ```

  - set

    ```c++
    #include <iostream>
    #include <set>
    using namespace std;
    
    int main() {
        set<int> st;
        st.insert(1);
        st.insert(10);
        st.insert(5);
        st.insert(-4);
        cout << st.size() << endl;
        st.erase(-4);
        cout << st.size() << endl;
        // 注意：set底层是红黑树，所以遍历顺序不一定是插入顺序
        for(auto it = st.begin(); it != st.end(); it++){
            cout << *it << endl;
        }
    
        if(st.find(1) != st.end()) cout << "find!!" << endl;
        else cout << "not find !!" << endl;
    
        st.clear();
    }
    ```

    







参考资料：

[^1]: [红黑树](https://www.cnblogs.com/skywang12345/p/3245399.html)
[^2]: [视频讲解红黑树](https://www.bilibili.com/video/BV1zU4y1H77f)
[^3]: [TCP连接状态详解](https://www.cnblogs.com/uestc2007/p/15481204.html)

[^4]: [操作系统系列面试题](https://zhuanlan.zhihu.com/p/391883855)

[^5]: [new/delete与malloc/free的区别与联系详解](https://blog.csdn.net/weibo1230123/article/details/81980889)

