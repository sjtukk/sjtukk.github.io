---
layout:     post
date:       2022-4-16
author:     "kk"
title: "C++基础"
header-style: text
tags:
  - 基础
---



## 语法

- 数组作为函数参数

  ```
  int a[][];
  void func(int a[][]){
  	
  }
  
  int b[]
  void func1(int a[]){
  
  }
  ```

- 初始化

  全局变量和静态变量会默认初始化

  局部变量不会默认初始化

  - 数组初始化

    ```
    int a[10] = {0};  // 会使a中所有元素设为0，但是仅限于0的情况
    int b[10] = {1};  // 这种只会让b[0] = 1，其他元素的值不确定
    memset(b, 0 ,sizeof(b)) // 也可以将数组b设为0，注意：memset是以字节为单位进行初始化的
    memset(b, 3, sizeof(b)) // 他会让每个字节赋值为 00000011，而一个int型占据了4个字节，这样赋值出来的结果就是不对的
    
    int a[10][10] = {0} // 可以初始化为0
    memset(a, 0, sizeof(a)) // 也可以初始化为0
    
    bool a[10] = {false} // 可以初始化为false
    bool a[10] = {true}  // 只有a[0] 为true
    ```

  - vector初始化

    ```
    vector<int>a(10);  // 默认就是0了
    vector<int>a(10,3);  // 所有元素都是3了
    
    // 二维vector
    vector<vector<int>> vec(10, vector<int>(5));  // 10行5列全是0
    vector<vector<int>> vec(10, vector<int>(5, 3)); // 10行5列全是3
    ```

- 别名

  - using

    using fmtfl = std::ios_base::fmtflags

  - typedef

    typedef std::ios_base::fmtflags fmtfl

  - typedef typename

    typedef typename _Hashtable::key_type	key_type;

    告诉编译器Hashtable::key_type是一个类型而不是_Hashtable的静态变量

- 四种转型

  - static_cast

    - 原有的自动类型转换，例如 short 转 int、int 转 double、const 转非 const、向上转型等；

    - void 指针和具体类型指针之间的转换，例如`void *`转`int *`、`char *`转`void *`等；
    - 有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）

    需要注意的是，static_cast 不能用于无关类型之间的转换，因为这些转换都是有风险的，例如：

    - 两个具体类型指针之间的转换，例如`int *`转`double *`
    - int 和指针之间的转换。将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件

    ​				static_cast 也不能用来去掉表达式的 const 修饰和 volatile 修饰。换句话说，不能将 const/volatile 类型转换为非 const/volatile 类型。

    ​				static_cast 是“静态转换”的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。

  - const_cast

    - 它用来去掉表达式的 const 修饰或 volatile 修饰。换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型。

  - reinterpret_cast

    reinterpret_cast 可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换（有些编译器只允许 int 转指针，不允许反过来）。

  - dynamic_cast

    - 向上转型时，只要待转换的两个类型之间存在继承关系，并且基类包含了虚函数（这些信息在编译期间就能确定），就一定能转换成功。因为向上转型始终是安全的，所以 dynamic_cast 不会进行任何运行期间的检查，这个时候的 dynamic_cast 和 static_cast 就没有什么区别了。
    - 向下转型是有风险的，dynamic_cast 会借助 RTTI 信息进行检测，确定安全的才能转换成功，否则就转换失败
      - 在向下转型前，必须要经过向上转型。这样才是安全的

- 左值、右值
