# JVM

## 内存布局

  - 栈（虚拟机栈、本地方法栈）、堆、程序计数器、方法区（jdk7是永久代，jdk8是元空间）

    线程私有：栈、程序计数器

    线程公有：堆、方法区

    ![image-20220419163635227](C:\Users\97691\AppData\Roaming\Typora\typora-user-images\image-20220419163635227.png)



- 方法区是一个逻辑概念，jdk7及以前，用永久代实现，它是JVM内存里面的一块区域，jdk8之后，永久代中的字符串常量池和静态变量移到了堆里，类信息移到了本地内存里

- 字符串常量池

  常量池底层就是一个HashMap，计算字符串的hash值

  - 以字面量方式创建的string存放在字符串常量池中，而用new 方式创建的存放在常量池外，即使new string()的字符串都是一样的，它还是会分配不同的地址
  - 而用字面量创建字符串时，如果字符串在常量池中（先比较hashcode然后调用equals方法比较），那么把该string对象的引用赋给该变量，如果没在，才会在常量池中新建string对象
  - 使用string.intern()方法能够将字符串加入到常量池里。在jdk6以前，会直接复制一份对象到常量池，但在jdk6之后，不是复制对象了，而是把引用放到常量池

- 出现Out of memory的情况
  - 申请的大对象超过了堆的空间。比如创建一个很大的数组
  - 某些对象虽然已经不使用了，但是无法被垃圾回收，导致内存逐渐被消耗
  - 垃圾回收的效率低。导致垃圾回收的效率比不过垃圾产生的效率
  - 线程过多
  - 加载的类过多



## 垃圾回收

### 垃圾回收算法
  - mark and copy：主要用于新生代
  - mark and compact：主要用于老年代
  - mark and sweep
  - GC root：虚拟机栈引用的对象、本地方法栈中引用的对象、方法区中类的静态属性引用的对象、
    方法区中常量引用的对象

- GC的分类
  - partial GC 
    - minor GC / young GC：针对于新生代。当新生代的Eden区满的时候，触发young GC
    - major GC / old GC ：针对于老年代
    - mixed GC：针对于整个新生代与部分老年代
  - full GC ：对java堆和方法区进行垃圾回收

- 出现OOM后，如何进行排查

  - 首先用内存映像分析工具对dump出来的堆内存快照进行分析，查看内存中的对象是否都是有必要的，判断是出现了内存溢出还是内存泄露

  - 如果是出现了内存泄露，通过工具查看GC Roots的引用链，找到泄露对象是在引用过程中哪里出现了内存泄露

  - 如果是内存溢出，且对象都是有必要的，那么就需要调整jvm的对的大小

    `-Xmx`:堆的最大值参数

    `-Xms`:堆的最小值参数

    `-XX:+HeapDumpOnoutOf-MemoryError`:可以让虚拟机在出现[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)溢出异常时Dump出当前的内存堆转储快照便于后面进行分析

### 垃圾回收器

<img src="C:\Users\97691\AppData\Roaming\Typora\typora-user-images\image-20220830222750969.png" alt="image-20220830222750969" style="zoom:50%;" />

CMS垃圾回收器：concurrent mark sweep。采用多线程的标记-清除算法。

- 初始标记：标记GC Roots能直接关联的对象。需要暂停工作线程
- 并发标记：进行GC Roots的追踪。不需要暂停工作线程
- 重新标记：因为在并发标记阶段，工作线程没有暂停，所以还会产生一部分的垃圾，所以进行重新标记。需要暂停工作线程
- 并发清除：回收垃圾。不需要暂停工作线程

G1垃圾回收器：Garbage first。采用多线程标记-整理算法

- 将内存划分为若干个区域（region），使新生代、老年代空间不需要连续。它同时兼顾了老年代与新生代的垃圾回收
- 采用标记整理算法，不会产生碎片
- 避免全区域的垃圾收集，而是优先回收垃圾最多的区域
- 可以较为精准地控制停顿时间，在不牺牲吞吐量的前提下，实现低停顿垃圾回收



## 类加载

  - 双亲委派模型：会一直往上让它的父类加载器进行加载
    - 双亲委派是向上委托加载的，可以保证父类加载器加载过的类，不会被重复加载
    - 对于系统类，保证不会被篡改，保证一定的安全性