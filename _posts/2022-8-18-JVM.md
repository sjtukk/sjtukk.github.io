# JVM

## 内存布局

  - 栈（虚拟机栈、本地方法栈）、堆、程序计数器、方法区（jdk7是永久代，jdk8是元空间）

    线程私有：栈、程序计数器

    线程公有：堆、方法区

    ![image-20220419163635227](C:\Users\97691\AppData\Roaming\Typora\typora-user-images\image-20220419163635227.png)



- 方法区是一个逻辑概念，jdk7及以前，用永久代实现，它是JVM内存里面的一块区域，jdk8之后，永久代中的字符串常量池和静态变量移到了堆里，类信息移到了本地内存里

- 字符串常量池

  常量池底层就是一个HashMap，计算字符串的hash值

  - 以字面量方式创建的string存放在字符串常量池中，而用new 方式创建的存放在常量池外，即使new string()的字符串都是一样的，它还是会分配不同的地址
  - 而用字面量创建字符串时，如果字符串在常量池中（先比较hashcode然后调用equals方法比较），那么把该string对象的引用赋给该变量，如果没在，才会在常量池中新建string对象
  - 使用string.intern()方法能够将字符串加入到常量池里。在jdk6以前，会直接复制一份对象到常量池，但在jdk6之后，不是复制对象了，而是把引用放到常量池

## 垃圾回收
### 垃圾回收算法
  - mark and copy：主要用于新生代
  - mark and compact：主要用于老年代
  - mark and sweep
  - GC root：虚拟机栈引用的对象、本地方法栈中引用的对象、方法区中类的静态属性引用的对象、
  方法区中常量引用的对象


## 类加载

  - 双亲委派模型：会一直往上让它的父类加载器进行加载
    - 双亲委派是向上委托加载的，可以保证父类加载器加载过的类，不会被重复加载
    - 对于系统类，保证不会被篡改，保证一定的安全性