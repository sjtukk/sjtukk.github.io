---
layout:     post
date:       2022-4-11
author:     "kk"
title: "计算机网络"
header-style: text
tags:
  - 面试
---





# 应用层协议

## Http协议

- 浏览器输入url后，会进行什么过程？
  - 如果浏览器有缓存，直接显示页面，如果没有缓存，往下执行
  - 将域名解析为ip地址（查询缓存，查询本机host，查询本地DNS，查询DNS根服务器，一级一级网上找，直到查询到IP）
  - 浏览器与服务器发起TCP三次握手
  - 握手成功后，发送http请求
  - 服务器响应请求，通过http返回数据
  - 浏览器根据返回的数据，以及页面的js，生成dom树，进行渲染

​			**http基于TCP协议**

- http协议的特点？

  - 无连接：每次连接只处理一个请求，服务器完成客户端的请求后，TCP就断开连接（http1.0）

    http1.1版本后，允许运行在一个 TCP 连接上发送多个命令和应答。因此大幅度减少了 TCP 连接的建立和断开，提高了效率。

  - 无状态：每一次请求都是独立的，不记录客户端任何行为

    解决方式：cookie和session

- http和https有什么区别？

  - HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。

  - HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。

  - HTTP 的端口号是 80，HTTPS 的端口号是 443。

  - HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的

- https如何保证安全性？
  - 在建立https连接时，会经过TCP三次握手，在加上**SSL/TLS**四次握手
  - 采用对称加密传输数据，采用非对称加密来传输“对称加密”的秘钥
  - 通过CA来颁发证书来保证公钥的可靠性

- http协议由什么组成？

  - 请求报文

    - 请求行：url，http协议版本

    - 请求头部（下面罗列了部分重要的）：

      host：初始url中的主机和端口

      cookie

      Accept-Encoding：浏览器能够进行解码的数据编码方式

      Accept-Charset：浏览器可接受的字符集；

      Connection：表示是否需要持久连接（http1.1以上）

      Content-Length：表示请求消息正文的长度

    - 空行

    - 请求数据

  - 响应报文：

    - 状态行：协议版本，状态码

    - 消息报头

      Content-Encoding：文档的编码(Encode)方法

      Content-Length：表示内容长度

      Set-Cookie：设置和页面关联的Cookie

    - 响应正文

- http协议Get请求和Post请求的区别

  - 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）。而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。（这个回答有问题，具体要看服务器的实现方式）
  - Get传输数据是通过URL请求，数据放到url后面，用？和&连接，对用户是可见的，安全性比post低。post请求是将字段和对应的值封装在请求实体中发送给服务器，这个过程对用户不可见
  - 受到浏览器的url长度的限制，get传输的数据量小，post可以传输大量数据
  - get是会被浏览器主动缓存的，如果下一次传输的数据相同，那么就会返回缓存中的内容，以求更快地展示数据。

- http状态码

  - 1xx     信息，服务器收到请求，需要请求者继续执行操作
    - 100（继续） 服务器已收到请求的第一部分，正在等待其余部分

  - 2xx    成功，操作被成功接收并处理
    - 200（成功） 请求被正确处理并返回了结果
  - 3xx     重定向，需要进一步的操作以完成请求
    - 301：永久性重定向
    - 302：临时重定向
    - 304：发送附带条件的请求时，条件不满足时返回，与重定向无关

  - 4xx     客户端错误，请求包含语法错误或无法完成请求
    - 400：请求报文语法有误
    - 401：请求需要认证
    - 403：请求的对应资源禁止访问
    - 404：服务器找不到对应资源

  - 5xx    服务器错误，服务器在处理请求的过程中发生了错误
    - 500：服务器内部错误
    - 503：服务器正忙

# 传输层协议

## TCP协议

- TCP中为什么要三次握手，四次挥手（TCP是全双工的）

  A与B建立连接 

  A向B发出请求，然后B做一次应答，这样就可以确定B是正常的，B向A发一次请求，然后A做一次应答， 这样可以确定A是正常的。本来应该是四次握手的，但是B对A的应答和B对A发的请求合在一次，作为一次，所以只需要三次握手。

  A与B断开连接

  A告知B，要断开连接，B回答A表明我知道了。同样B也要告知A，要断开连接了，A回答B表明我知道了。在断开连接的时候为什么不能将B对A的应答和B对A发的请求合在一次呢？因为这个时候B可能还要向A传递数据，所以B先应答A（表明B知道A要断开连接了，但是B有可能还要传输数据），等数据传输完之后，才会发出断开连接的请求。所以不能合在一起。

  故是：三次握手，四次挥手

  不进行两次握手是因为，如果A发出的请求连接在网络传输中延迟了，A重新发起了建立连接的请求，与B建立连接，等数据传输完成断开连接后，那个延迟的请求连接包又到了，这个时候B以为A又重新发起了一次请求，就一直等待请求中

- TCP四次挥手中，客户端在发出ACK报文后等待2msl（Maximum Segment Lifetime，最大报文寿命）才关闭客户端，是为了什么？

  - 防止客户端最后一次发给服务器的确认在网络中丢失以至于客户端关闭，而服务端并未关闭，导致资源的浪费。

    如果服务端未收到ACK报文，会重发FIN报文，直到收到ACK后，才会关闭服务端

  - 等待最大的2msl可以让本次连接的所有的网络包在链路上消失，以防造成不必要的干扰

- TCP为什么是安全可靠的？

  - 首先TCP是面向连接的，不像UDP不需要建立连接
  - TCP中含有序号和确认序号，这保证了传输的可靠性。确认应答机制
  - 校验和。（计算TCP首部、TCP数据、TCP伪首部）
  - 超时重传。（对于没有及时收到应答的包进行重传）通过滑动窗口机制来提高效率

- TCP、UDP区别
  - tcp面向连接，udp无连接
  - tcp传输可靠，udp不可靠
  - UDP支持单播，多播，广播（一对一，一对多，一对全的通信）
  - TCP之间仅支持单播（一对一）

- TCP建立连接的过程？

  序号：seq（sequence number）序号占32位，用来标记客户端和服务器端之间发送的不同数据包，如客户端发送数据时利用seq对发送的数据包进行标记。
  确认号：ack（acknowledge number）确认号占32位，客户端和服务器端都可以发生，且ack=seq+1

  ACK：标志位的确认编号，表明确认连接（注意与上面的ack区分）

  SYN：建立一个新连接。
  FIN：断开一个连接。

  下面只体现了标志位，至于seq和ack，跟正常连接的时候没区别，只是第一次建立连接/释放连接的时候，只有seq没有ack，后面都有seq和ack

  - A向B（SYN ）
  - B向A（SYN + ACK ）：
  - A向B（ACK ）：
  - 建立连接成功

- TCP断开连接的过程？

  - A向B（FIN)
  - B向A（ACK）
  - B向A（FIN + ACK)
  - A向B（ACK）
  - 等待2msl
  - 断开连接成功

- TCP的连接状态？[^3]

  - LISTENING 

    提供某种服务，侦听远方TCP端口的连接请求，当提供的服务没有被连接时，处于LISTENING状态，端口是开放的，等待被连接。

  - SYN_SENT (客户端状态)

    客户端发送SYN请求连接，在等待服务器发送ACK的时候，处于SYN_SENT状态

  - SYN_RECEIVED (服务端状态)

    服务端收到客户端的SYN，并发送自己的SYN和ACK时，等待客户端ACK的时候，处于SYN_RECEIVED 状态

  - ESTABLISHED

    ESTABLISHED状态是表示两台机器正在传输数据。

  - FIN-WAIT-1

    主动关闭端应用程序调用close，TCP发出FIN请求主动关闭连接，之后进入FIN_WAIT1状态。

  - FIN-WATI-2

    主动关闭端接到ACK后，就进入了FIN-WAIT-2 .

  - CLOSE-WAIT

    被动关闭端TCP接到FIN后，就发出ACK以回应FIN请求, 并进入CLOSE_WAIT. 

  - TIME-WAIT

    主动关闭端接收到FIN后，TCP就发送ACK包，并进入TIME-WAIT状态,等待足够的时间以确保远程TCP接收到连接中断请求的确认,很大程度上保证了双方都可以正常结束,但是也存在问题，须等待2MSL时间的过去才能进行下一次连接。**状态迁移过程：**

     客户端：

　　　　CLOSED->SYN_SENT->ESTABLISHED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->CLOSED

　　		服务端

　　　　CLOSED->LISTEN->SYN_RECEIVED->ESTABLISHED->CLOSE_WAIT->LAST_ACK->CLOSE

- TCP拥塞控制

  - 慢开始：最开始指数增加，比如最开始发1个包，收到回复后，下一次同时发两个包，收到回复后，在下一次发4个包...
  - 拥塞避免：当慢开始的窗口长度大于某一阈值的时候，开始拥塞避免，一次增加一个窗口长度
  - 出现拥塞：若发出的包没有收到回复，重新回到1进行慢启动，并且将拥塞避免的阈值稍微上次出现拥塞的窗口长度的一半
  - 再次进行慢开始

  <img src="https://img-blog.csdnimg.cn/3e8f948e029c4cefa655070083a0e23b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

  ## UDP协议

- 与TCP协议的区别是什么？

  - tcp面向连接，udp无连接
  - tcp传输可靠，udp不可靠
  - UDP支持单播，多播，广播（一对一，一对多，一对全的通信）
    TCP之间仅支持单播（一对一）

# 网络层协议



# 数据链路层协议

## ARP协议

地址解析协议

获得目标ip的mac地址

网关发送arp广播包，所有在该网段下的主机检查自己的ip，如果是目标ip，就应答自己的mac地址



# 其他

- 集线器、交换机、集线器

  集线器：对于发送的数据包，不做任何的处理，无脑转发。比如集线器有3个端口（1，2，3），向1号端口发送数据，集线器会将数据转发到除1号端口外的所有端口。当网络中有多个主机同时发送的时候，就会出现冲突，需要采用冲突避免的协议（CSMA等）

​		二层交换机：比集线器智能一点，它不会无脑转发数据包。它会读取数据包中的目的mac地址，如果目标mac地址在交换表中，他就会直接转发到该端口，如果不在交换表中，就进行泛洪，转发到所有端口，匹配的目标mac地址的主机会做出应答，之后交换机会记录该mac地址所对应的端口号。

​	（泛洪和广播不一样：泛洪是将普通mac帧除发送端口外全部转发出去，而广播的mac帧目的mac地址是FFFFFFFF）

​		路由器：路由表记录下一跳的ip地址

​        首先将IP报文中的目的地址和路由表项中的子网掩码进行 “逻辑与” 操作，得到一个网络地址，然后拿此网络地址与转发表中的网络地址做比较，如果一致就认为匹配，否则认为不匹配。当路由表中存在多个路由项可以同时匹配目的IP地址时，路由查找进程会选择其中掩码最长的路由项进行转发， 掩码越长表明其代表的网络范围越小，匹配的程度就越精确。 这就是所谓的最长匹配原则。


​		

![img](https://img-blog.csdnimg.cn/2020062621120486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0N1aWVuamll,size_16,color_FFFFFF,t_70)



- 




参考资料：

[^1]: [红黑树](https://www.cnblogs.com/skywang12345/p/3245399.html)
[^2]: [视频讲解红黑树](https://www.bilibili.com/video/BV1zU4y1H77f)
[^3]: [TCP连接状态详解](https://www.cnblogs.com/uestc2007/p/15481204.html)

[^4]: [操作系统系列面试题](https://zhuanlan.zhihu.com/p/391883855)

[^5]: [new/delete与malloc/free的区别与联系详解](https://blog.csdn.net/weibo1230123/article/details/81980889)

[^6]: [你知道 Socket 是怎么创建的吗?](https://zhuanlan.zhihu.com/p/464268288)

